

local Loader = require 'class'

function shuffle(tensor)

   local input = tensor.input
   local label = tensor.label
   
   local shuffle_indexes = torch.randperm(input:size(1))
   
   local input_shuffled = torch.Tensor(input:size())
   local label_shuffled = torch.Tensor(label:size())
   
   for i=1,input:size(1),1 do
      input_shuffled[i] = input[shuffle_indexes[i]]
      label_shuffled[i] = label[shuffle_indexes[i]]
   end
   
   --tensor.input = input_shuffled
   --tensor.label = label_shuffled
   
   return input_shuffled,label_shuffled

end


function splitDataSet(x)

   --print()

   -- train = train
   -- val   = val 
   -- test  = test
   
   -- return train,val,test

end


function dataSet()
   
   local data = torch.load(paths.concat(opt.dataDir , opt.dataFileName))
   --a.input.shuffle()
   
   --local data = shuffle(data)
   local input,label = shuffle(data)
   
   -- print(data)

   local trainN = torch.floor(input:size(1)*opt.trainDataRate)
   local valN   = torch.floor(input:size()[1]*opt.validationDataRate)
   local testN  = input:size()[1] - (valN + trainN)
   
   -- print(trainN,valN,testN)
   -- print(input[{{1,trainN}}]:size())
   -- print(input[{{trainN+1,trainN + valN}}]:size())
   -- print(input[{{trainN + valN + 1, trainN + valN + testN}}]:size())
   
   local data = {

      train = {
	 input = input[{{1,trainN}}],
	 label = label[{{1,trainN}}]
      },

      validation = {
	 input = input[{{trainN+1,trainN + valN}}],
	 label = label[{{trainN+1,trainN + valN}}]
      },
      
      test = {
	 input = input[{{trainN + valN + 1, trainN + valN + testN}}],
	 label = label[{{trainN + valN + 1, trainN + valN + testN}}]
      }
   }

   print(data)

   return data

end

return Loader



